---
title: 使用ae表达式集中管理批量文字信息
tags: 
    - Ae
updated: 2020-07-26
date: 2020-07-26
categories: "影視"
---

>
# TL;DR

本篇简要介绍了通过单个对象进行文本表达式与``split``函数处理，拆分管理多个文本对象。通过描述一个场景来解释这种结构的优势，并附上逻辑表达式。

场景需求：
1. 动态歌词，即每句歌词需要有“入场动画”和“持续动画”，100句起步，假设可能会随时修改。
2. 在一个合成中，时间先后共50个人的人名条，每个人名条有持续动画，假设可能会随时修改。

**新思路的相对优势**：
1. 经过这样的思维转变，首先**文本元素得以统一控制，无需挨个修改**。避免了查找修改。
2. 其次利用AE增量复制特性，**动画的修改可以很快完成同步**（即删除合成，再复制，因为会根据合成的命名自动获取文本），避免了单个动画修改，全部都要重新填词的麻烦。
3. 相对于PS的批量填字脚本，这种思维是修改方便、灵活，而且**可以制作动态文本动画**（传统使用ps来填字幕，也只能填静态字幕）
<!--more-->

# 前言

场景需求：
1. 动态歌词，即每句歌词需要有“入场动画”和“持续动画”，假设可能会随时修改。
2. 在一个合成中，时间先后共50个人的人名条，每个人名条有持续动画，假设可能会随时修改。

简化来看，2的需求是1的拓展，动态歌词每一份，都需要一套固定的动画。这个需求涉及到两个变量：**内容和动画**

# 解决思路
**传统解决思路及其痛点**：
1. 制作一个基本动画，填入歌词，复制这个合成，修改歌词。
2. 这样我们制造出来n个带有**特定内容、相同动画**的合成
3. 如果需要修改内容，我们要找出对应的一个合成，修改内容
4. 如果需要修改全部动画，我们需要**把除了第一个以外的全部删掉，调整完，再全部复制，再重新执行一遍填词**

转变思维：
1. 使用一个跨越合成的对象，存储所有文本元素，称为**数据寄存**。
2. 创建一个动画合成，制作动画，将文本内容指向这个“数据寄存”。
3. 将合成通过命名区分，如“歌词 1”来指向“数据寄存”的**第一个对象**。
4. 复制这一个动画合成。（由于AE的复制是增量，所以特别快即可复制出一一对应的动画）。

**相对优势**：
1. 经过这样的思维转变，首先**文本元素得以统一控制，无需挨个修改**。避免了查找修改。
2. 其次利用AE增量复制特性，**动画的修改可以很快完成同步**（即删除合成，再复制，因为会根据合成的命名自动获取文本），避免了单个动画修改，全部都要重新填词的麻烦。
3. 相对于PS的批量填字脚本，这种思维是修改方便、灵活，而且**可以制作动态文本动画**（传统使用ps来填字幕，也只能填静态字幕）

实践准备（理清结构）：
1. 首先是需要一个跨合成对象，以及一个用于复制的基本动画合成。
2. 将基本动画合成的**文本**链接到**跨合成对象**的所有文本元素。（文本元素需要有一定的标识符区分开，我这里使用的是``\\n``）
3. 将基本动画合成命名为``[COMP_NAME] 1``（带空格和“1”），这个是AE增量复制的基本格式。
4. 读取合成名的数字，通过数字按顺序读取文本元素。

# 实践

Comp1：CoreData
1. 文本层.text.sourceText=``"A\\nB\\nC\\nD"``

Comp2：BasicAnime 1
1. 首先获取命名的数字：``var index=  parseInt(thisComp.name.split(" ")[1])``(需要用parseInt转换成int)
2. 然后获取跨合成的文本信息：文本层.text.sourceText=``var text = comp("CoreData").文本层.text.sourceText``
3. 文本信息需要经过split处理，按``\\n``切分，即：``text.split("\n")``（这里是使用``\n``，转义符语法自行查阅）
4. 通过刚刚的index获取文本信息：``text.split("\n")[index]``（如果需要，可以多加个offset控制）

以上步骤就完成了文本链接。所有文本的修改只需要在 CoreData 中进行即可。

制作动画后，复制该合成即可。你就得到了相同动画的所有文本动画。修改动画也只需修改其中一个，再删掉其他，粘贴就行。

# 后话

这个思路同样适用于同一个合成内（即 需求2），拥有快速、灵活修改的特性。